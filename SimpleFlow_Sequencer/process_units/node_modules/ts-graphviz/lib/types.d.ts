import { attribute } from './attribute';
/**
 * Directive indicating which direction the Edge should point.
 */
export declare type Compass = 'n' | 'ne' | 'e' | 'se' | 's' | 'sw' | 'w' | 'nw' | 'c';
export declare namespace Compass {
    /** Upper part */
    const n: Compass;
    /** Upper left */
    const ne: Compass;
    /** Left part */
    const e: Compass;
    /** Lower left */
    const se: Compass;
    /** Lower part */
    const s: Compass;
    /** Lower right */
    const sw: Compass;
    /** Right part */
    const w: Compass;
    /** Upper right */
    const nw: Compass;
    /** Center */
    const c: Compass;
    /**
     * Determine whether the character string satisfies the Compass condition.
     */
    function is(str: string): str is Compass;
}
/**
 * Objects that can be Edge destinations satisfy this interface.
 */
export declare type EdgeTarget = INode | INodeWithPort | IForwardRefNode;
export declare type EdgeTargets = ReadonlyArray<EdgeTarget>;
/**
 * string or an object implementing IEdgeTarget.
 */
export declare type EdgeTargetLike = EdgeTarget | string;
export declare type EdgeTargetsLike = ReadonlyArray<EdgeTargetLike>;
export interface IHasComment {
    /** Comments to include when outputting with toDot. */
    comment?: string;
}
export interface IHasAttributes<T extends string> {
    readonly attributes: IAttributes<T>;
}
/**
 * An AttributesValue is one of the following:
 * - Any string of alphabetic ([a-zA-Z\200-\377]) characters, underscores ('_') or digits ([0-9]), not beginning with a digit;
 * - a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? );
 * - any double-quoted string ("...") possibly containing escaped quotes (\")1;
 * - an HTML Like string (<...>).
 */
export declare type AttributesValue = string | number | boolean;
export declare type AttributesObject<T extends string> = {
    [key in T]?: AttributesValue;
};
export declare type AttributesEntities<T extends string> = readonly [T, AttributesValue][];
export declare type EdgeAttributes = AttributesObject<attribute.Edge>;
export declare type NodeAttributes = AttributesObject<attribute.Node>;
export declare type RootClusterAttributes = AttributesObject<attribute.RootCluster>;
export declare type ClusterSubgraphAttributes = AttributesObject<attribute.ClusterSubgraph | attribute.Subgraph>;
export interface IAttributesBase<T extends string> {
    readonly size: number;
    readonly values: ReadonlyArray<[T, AttributesValue]>;
    get(key: T): AttributesValue | undefined;
    set(key: T, value: AttributesValue): void;
    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;
    delete(key: T): void;
    clear(): void;
}
export interface IAttributes<T extends string = string> extends IAttributesBase<T>, IHasComment {
}
export interface IPort {
    port: string;
    compass: Compass;
}
export interface INodeWithPort {
    readonly node: INode;
    readonly port: Partial<IPort>;
}
export interface IForwardRefNode {
    readonly id: string;
    readonly port: Partial<IPort>;
}
export interface INode extends IHasComment, IHasAttributes<attribute.Node> {
    readonly id: string;
    port(port: string | Partial<IPort>): INodeWithPort;
}
export interface IEdge extends IHasComment, IHasAttributes<attribute.Edge> {
    readonly targets: ReadonlyArray<EdgeTarget | EdgeTargets>;
}
/**
 * Cluster common attribute interface.
 *
 * @hidden
 */
export interface IClusterCommonAttributes {
    /** Manage common attributes of graphs in a cluster. */
    graph: IAttributes<attribute.Subgraph | attribute.ClusterSubgraph>;
    /** Manage common attributes of edges in a cluster. */
    edge: IAttributes<attribute.Edge>;
    /** Manage common attributes of nodes in a cluster. */
    node: IAttributes<attribute.Node>;
}
export interface ICluster<T extends string = string> extends IHasComment, IAttributesBase<T> {
    readonly id?: string;
    readonly attributes: Readonly<IClusterCommonAttributes>;
    readonly nodes: ReadonlyArray<INode>;
    readonly edges: ReadonlyArray<IEdge>;
    readonly subgraphs: ReadonlyArray<ISubgraph>;
    /**
     * Add a Node to the cluster.
     */
    addNode(node: INode): void;
    /**
     * Add Edge to the cluster.
     */
    addEdge(edge: IEdge): void;
    /**
     * Add a Subgraph to the cluster.
     */
    addSubgraph(subgraph: ISubgraph): void;
    /**
     * Check if the Node exists in the cluster.
     */
    existNode(nodeId: string): boolean;
    /**
     * Check if the Edge exists in the cluster.
     */
    existEdge(edge: IEdge): boolean;
    /**
     * Check if the Subgraph exists in the cluster.
     */
    existSubgraph(subgraph: ISubgraph): boolean;
    /**
     * Remove Node from the cluster.
     */
    removeNode(node: INode | string): void;
    /**
     * Remove Edge from the cluster.
     */
    removeEdge(edge: IEdge): void;
    /**
     * Remove Subgraph from the cluster.
     */
    removeSubgraph(subgraph: ISubgraph): void;
    /**
     * Create a Node in the cluster.
     */
    createNode(id: string, attributes?: NodeAttributes): INode;
    /**
     * Create a Subgraph and add it to the cluster.
     */
    createSubgraph(id?: string, attributes?: ClusterSubgraphAttributes): ISubgraph;
    createSubgraph(attributes?: ClusterSubgraphAttributes): ISubgraph;
    /**
     * Get Subgraph in cluster by specifying id.
     *
     * If there is no Subgraph with the specified id in the cluster, return undefined.
     */
    getSubgraph(id: string): ISubgraph | undefined;
    /**
     * Get Node in cluster by specifying id.
     *
     * @description
     * If there is no Node with the specified id in the cluster, return undefined.
     */
    getNode(id: string): INode | undefined;
    /** Create Edge and add it to the cluster. */
    createEdge(targets: (EdgeTargetLike | EdgeTargetsLike)[], attributes?: EdgeAttributes): IEdge;
    /**
     * Declarative API for Subgraph.
     *
     * @description
     * If there is a Subgraph with the given ID, use it.
     * If not, create a Subgraph.
     *
     * @param id Subgraph ID.
     * @param attributes Subgraph attributes.
     * @param callback Callback to operate Subgraph.
     */
    subgraph(id?: string, callback?: (subgraph: ISubgraph) => void): ISubgraph;
    subgraph(id?: string, attributes?: ClusterSubgraphAttributes, callback?: (subgraph: ISubgraph) => void): ISubgraph;
    subgraph(attributes?: ClusterSubgraphAttributes, callback?: (subgraph: ISubgraph) => void): ISubgraph;
    subgraph(callback?: (subgraph: ISubgraph) => void): ISubgraph;
    /**
     * Declarative API for Node.
     *
     * @description
     * If there is a Node with the given ID, use it.
     * If not, create a Node.
     *
     * @param id Node ID.
     * @param attributes Node attributes.
     * @param callback Callback to operate Node.
     */
    node(id: string, callback?: (node: INode) => void): INode;
    node(id: string, attributes?: NodeAttributes, callback?: (node: INode) => void): INode;
    /**
     * Declarative API for Edge.
     *
     * @param targets Edges.
     * @param attributes Edge attributes.
     * @param callback Callback to operate Edge.
     */
    edge(targets: (EdgeTargetLike | EdgeTargetsLike)[], callback?: (edge: IEdge) => void): IEdge;
    edge(targets: (EdgeTargetLike | EdgeTargetsLike)[], attributes?: EdgeAttributes, callback?: (edge: IEdge) => void): IEdge;
}
export interface ISubgraph extends ICluster<attribute.Subgraph | attribute.ClusterSubgraph> {
    isSubgraphCluster(): boolean;
}
export interface IRootCluster extends ICluster<attribute.RootCluster> {
    /**
     * Strict mode.
     *
     * @description
     * A graph may also be described as strict.
     * This forbids the creation of multi-edges, i.e., there can be at most one edge with a given tail node and head node in the directed case.
     * For undirected graphs, there can be at most one edge connected to the same two nodes.
     * Subsequent edge statements using the same two nodes will identify the edge with the previously defined one and apply any attributes given in the edge statement.
     */
    strict: boolean;
}
export declare type Dot = IRootCluster | ISubgraph | IEdge | INode | IAttributes | AttributesValue;
